"use strict";(self.webpackChunkquant_docs=self.webpackChunkquant_docs||[]).push([[9345],{3905:function(e,t,n){n.d(t,{Zo:function(){return c},kt:function(){return g}});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function u(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var s=a.createContext({}),l=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},c=function(e){var t=l(e.components);return a.createElement(s.Provider,{value:t},e.children)},p="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},h=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,s=e.parentName,c=u(e,["components","mdxType","originalType","parentName"]),p=l(n),h=r,g=p["".concat(s,".").concat(h)]||p[h]||d[h]||o;return n?a.createElement(g,i(i({ref:t},c),{},{components:n})):a.createElement(g,i({ref:t},c))}));function g(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,i=new Array(o);i[0]=h;var u={};for(var s in t)hasOwnProperty.call(t,s)&&(u[s]=t[s]);u.originalType=e,u[p]="string"==typeof e?e:r,i[1]=u;for(var l=2;l<o;l++)i[l]=n[l];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}h.displayName="MDXCreateElement"},602:function(e,t,n){n.r(t),n.d(t,{assets:function(){return c},contentTitle:function(){return s},default:function(){return g},frontMatter:function(){return u},metadata:function(){return l},toc:function(){return p}});var a=n(7462),r=n(3366),o=(n(7294),n(3905)),i=["components"],u={id:"purger",title:"Using quant_purger",sidebar_label:"Purger"},s=void 0,l={unversionedId:"integrations/drupal/purger",id:"integrations/drupal/purger",title:"Using quant_purger",description:"The optional quant_purger submodule adds cache tag support for Quant content seeding. This relies on the Purge API and allows the Quant module suite to identify pages (including related content) that require updating based on user actions and then queues them for seeding.",source:"@site/docs/integrations/drupal/purger.md",sourceDirName:"integrations/drupal",slug:"/integrations/drupal/purger",permalink:"/docs/integrations/drupal/purger",draft:!1,editUrl:"https://github.com/quantcdn/docs/tree/develop/docs/integrations/drupal/purger.md",tags:[],version:"current",frontMatter:{id:"purger",title:"Using quant_purger",sidebar_label:"Purger"},sidebar:"someSidebar",previous:{title:"Run a Seed",permalink:"/docs/integrations/drupal/seed"},next:{title:"Cron setup",permalink:"/docs/integrations/drupal/drupal-cron"}},c={},p=[{value:"How does it work?",id:"how-does-it-work",level:2},{value:"Setup",id:"setup",level:2},{value:"Additional configuration",id:"additional-configuration",level:2},{value:"Example usage",id:"example-usage",level:2}],d={toc:p},h="wrapper";function g(e){var t=e.components,u=(0,r.Z)(e,i);return(0,o.kt)(h,(0,a.Z)({},d,u,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("p",null,"The optional ",(0,o.kt)("inlineCode",{parentName:"p"},"quant_purger")," submodule adds ",(0,o.kt)("a",{parentName:"p",href:"https://www.drupal.org/docs/drupal-apis/cache-api/cache-tags"},"cache tag")," support for ",(0,o.kt)("a",{parentName:"p",href:"/docs/integrations/drupal/seed"},"Quant content seeding"),". This relies on the ",(0,o.kt)("a",{parentName:"p",href:"https://www.drupal.org/project/purge"},"Purge API")," and allows the Quant module suite to identify pages (including related content) that require updating based on user actions and then queues them for seeding."),(0,o.kt)("h2",{id:"how-does-it-work"},"How does it work?"),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"quant_purger")," module creates a reference database table (",(0,o.kt)("inlineCode",{parentName:"p"},"purge_queuer_quant"),") that is used to map Drupal-generated cache tags to paths that have been seeded to Quant."),(0,o.kt)("p",null,"When Drupal issues a cache clear event, the Purge module collects that information and exposes it so that reverse proxies can be invalidated. In Quant's use case, this provides an entry point for the Quant module suite to identify which cache tags require clearing and use that information to create queue entries that can be seeded to Quant on the next queue run."),(0,o.kt)("h2",{id:"setup"},"Setup"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"Enable the ",(0,o.kt)("inlineCode",{parentName:"li"},"quant_purger")," module"),(0,o.kt)("li",{parentName:"ol"},"Seed your content to create entries in the reference table")),(0,o.kt)("admonition",{type:"tip"},(0,o.kt)("p",{parentName:"admonition"},"To identify the cache tags that are associated with your site, you can access them from the reference table:"),(0,o.kt)("pre",{parentName:"admonition"},(0,o.kt)("code",{parentName:"pre"},'drush sqlq "select url, tags from purge_queuer_quant"\n'))),(0,o.kt)("h2",{id:"additional-configuration"},"Additional configuration"),(0,o.kt)("p",null,"Drupal has a large number of cache tags, so some common cache tags are on the tag blocklist by default as they appear on every page (e.g., ",(0,o.kt)("inlineCode",{parentName:"p"},"rendered"),"). You can remove any of the default tags but keep in mind this may have a negative performance impact."),(0,o.kt)("p",null,"In order for cache tag purging to be effective and efficient, inspect the cache tags that are present on the URLs in the reference table and update the tag blocklist with tags to exclude. For example, if you don't want content to be queued for seeding when a particular media item is updated, you can add the cache tag for that media item to the tag blocklist."),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"Enable the ",(0,o.kt)("inlineCode",{parentName:"li"},"purge_ui")," companion module"),(0,o.kt)("li",{parentName:"ol"},"Edit the ",(0,o.kt)("strong",{parentName:"li"},"Purge Quant")," queuer configuration"),(0,o.kt)("li",{parentName:"ol"},"Update the tag blocklist")),(0,o.kt)("p",null,"You can also update the path blocklist if there are certain paths that you don't want to be queued for seeding during cache clear events."),(0,o.kt)("p",null,(0,o.kt)("img",{alt:"Quant Purger queue configuration",src:n(9862).Z,width:"2062",height:"1552"})),(0,o.kt)("admonition",{type:"tip"},(0,o.kt)("p",{parentName:"admonition"},"The current tag list can be viewed with ",(0,o.kt)("inlineCode",{parentName:"p"},"drush config:get quant_purger.settings tag_blocklist"))),(0,o.kt)("p",null,"If you want to delete the values from the reference database table, you can use the ",(0,o.kt)("inlineCode",{parentName:"p"},"Clear the registry")," button through the Purge UI or you can delete them directly in the database. In order to populate the table again, you must run a seed."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},'drush sqlq "delete from purge_queuer_quant"\n')),(0,o.kt)("h2",{id:"example-usage"},"Example usage"),(0,o.kt)("p",null,"A site has blog posts with category taxonomy terms shown on them. The names of the categories change sometimes, but the editorial team has decided that it's not critical for these changes to be reflected on the static website quickly."),(0,o.kt)("p",null,"There is already a process in place for reseeding the site during each weekly development release. The editors have agreed that it's okay if the category changes don't show up until the weekly reseeding happens. So, the developers add the cache tags for these taxonomy terms to the tag blocklist."),(0,o.kt)("p",null,"When an editor changes one of these category terms, none of the associated content is queued for reseeding, which is what they want. Later, they decide to reverse this policy and remove the cache tag from the tag blocklist. Now, when an editor changes a category term, all the content associated with that term is queued for seeding."),(0,o.kt)("p",null,"They are using the ",(0,o.kt)("a",{parentName:"p",href:"/docs/integrations/drupal/drupal-cron"},(0,o.kt)("inlineCode",{parentName:"a"},"quant_cron")," module")," to process a certain number of items from the queue during each cron, so it handles these new queue items. Occassionally, they run the seed processing with ",(0,o.kt)("inlineCode",{parentName:"p"},"drush quant:run-queue")," when they want to make sure all the pressing changes show up."))}g.isMDXComponent=!0},9862:function(e,t,n){t.Z=n.p+"assets/images/quant-purger-config-a2cb82d2f6dd5e15e0bf67a7a17ea173.png"}}]);